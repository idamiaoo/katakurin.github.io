<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="You know nothing"><title>HTTPs and Golang | 记忆源泉</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HTTPs and Golang</h1><a id="logo" href="/.">记忆源泉</a><p class="description">You know nothing</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">HTTPs and Golang</h1><div class="post-meta">2017-07-14<span> | </span><span class="category"><a href="/categories/golang/">golang</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">HTTPS简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84HTTPS-Web-Server"><span class="toc-number">2.</span> <span class="toc-text">实现一个最简单的HTTPS Web Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-number">3.</span> <span class="toc-text">非对称加密和数字证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A7%81%E9%92%A5%E4%B8%8E%E8%AF%81%E4%B9%A6"><span class="toc-number">4.</span> <span class="toc-text">服务端私钥与证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%AF%81%E4%B9%A6%E8%BF%9B%E8%A1%8C%E6%A0%A1%E9%AA%8C"><span class="toc-number">5.</span> <span class="toc-text">对服务端的证书进行校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AF%81%E4%B9%A6%E8%BF%9B%E8%A1%8C%E6%A0%A1%E9%AA%8C-%E5%8F%8C%E5%90%91%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">对客户端的证书进行校验(双向证书校验）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="post-content"><p>近期在构思一个产品，考虑到安全性的原因，可能需要使用到HTTPS协议以及双向数字证书校验。之前只是粗浅接触过HTTP（使用Golang开 发微信系列）。对HTTPS的了解则始于那次自行搭建ngrok服务，在那个过程中照猫画虎地为服务端生成了一些私钥和证书，虽然结果是好 的：ngrok服务成功搭建起来了，但对HTTPS、数字证书等的基本原理并未求甚解。于是想趁这次的机会，对HTTPS做一些深度挖掘。主要途 径：翻阅网上资料、书籍，并利用golang编写一些实验examples。  </p>
<h3 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h3><p>日常生活中，我们上网用的最多的应用层协议就是HTTP协议了，直至目前全世界的网站中大多数依然只支持HTTP访问。  </p>
<p>使用Go创建一个HTTP Server十分Easy，十几行代码就能搞定：  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gohttps/1-http/server.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w,</span><br><span class="line">     <span class="string">&quot;Hi, This is an example of http service in golang!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行这段代码：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run server.go  </span><br></pre></td></tr></table></figure>
<p>打开浏览器，在地址栏输入”<a href="http://localhost:8080&quot;，">http://localhost:8080&quot;，</a> 你会看到“ Hi, This is an example of http service in golang!”输出到浏览器窗口。</p>
<p>不过HTTP毕竟是明文的，在这样一个不安全的世界里，随时存在着窃听（sniffer工具可以简单办到）、篡改甚至是冒充等风险，因此对于一些 对安全比较care的站点或服务，它们需要一种安全的HTTP协议，于是就有了HTTPS。  </p>
<p>HTTPS只是我们在浏览器地址栏中看到协议标识，实际上它可以被理解为运行在SSL（Secure Sockets Layer）或TLS(Transport Layer Security)协议所构建的安全层之上的HTTP协议，协议的传输安全性以及内容完整性实际上是由SSL或TLS保证的。  </p>
<p>关于HTTPS协议原理的详细说明，没有个百八十页是搞不定的，后续我会在各个实验之前将相关的原理先作一些说明，整体原理这里就不赘述了。有兴 趣的朋友可以参考以下资料：<br>1、《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10746113/">HTTP权威指南</a>》第十四章<br>2、《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/25863515/">图解HTTP</a>》第七章<br>3、阮一峰老师的两篇博文“<a href="">SSL/TLS协议运行机制的概述</a>“和”<a href="">图解SSL/TLS协议</a>“。  </p>
<h3 id="实现一个最简单的HTTPS-Web-Server"><a href="#实现一个最简单的HTTPS-Web-Server" class="headerlink" title="实现一个最简单的HTTPS Web Server"></a>实现一个最简单的HTTPS Web Server</h3><p>Golang的标准库net/http提供了https server的基本实现，我们修改两行代码就能将上面的HTTP Server改为一个HTTPS Web Server:  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gohttps/2-https/server.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w,</span><br><span class="line">        <span class="string">&quot;Hi, This is an example of https service in golang!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">    http.ListenAndServeTLS(<span class="string">&quot;:8081&quot;</span>, <span class="string">&quot;server.crt&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;server.key&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用http.ListenAndServeTLS替换掉了http.ListenAndServe，就将一个HTTP Server转换为HTTPS Web Server了。不过ListenAndServeTLS 新增了两个参数certFile和keyFile，需要我们传入两个文件路径。到这里，我们不得不再学习一点HTTPS协议的原理了。不过为 了让这个例子能先Run起来，我们先执行下面命令，利用openssl生成server.crt和server.key文件，供程序使用，原 理后续详述：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$openssl</span> genrsa -out server.key 2048</span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">…………….+++</span><br><span class="line">……………+++</span><br><span class="line">e is 65537 (0×10001)</span><br><span class="line"><span class="variable">$openssl</span> req -new -x509 -key server.key -out server.crt -days 365</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">&#x27;.&#x27;</span>, the field will be left blank.</span><br><span class="line">—–</span><br><span class="line">Country Name (2 letter code) [AU]:</span><br><span class="line">State or Province Name (full name) [Some-State]:</span><br><span class="line">Locality Name (eg, city) []:</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:localhost</span><br><span class="line">Email Address []:</span><br></pre></td></tr></table></figure>
<p>执行程序：go run server.go<br>通过浏览器访问：<a href="https://localhost:8081，chrome浏览器会显示如下画面：">https://localhost:8081，chrome浏览器会显示如下画面：</a><br><img src="http://tonybai.com/wp-content/uploads/gohttps-chrome-unsecure-connection.png"></p>
<p>忽略继续后，才能看到”Hi, This is an example of https service in golang!”这个结果输出在窗口上。  </p>
<p>也可以使用curl工具验证这个HTTPS server：  </p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -k <span class="keyword">https</span>://localhost:<span class="number">8081</span></span><br><span class="line">Hi, This is <span class="keyword">an</span> example <span class="keyword">of</span> <span class="keyword">http</span> service <span class="keyword">in</span> golang!</span><br></pre></td></tr></table></figure>
<p>注意如果不加-k，curl会报如下错误：  </p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> https:<span class="comment">//localhost:8081</span></span><br><span class="line"><span class="comment">curl: (60) SSL certificate problem: Invalid certificate chain</span></span><br><span class="line"><span class="comment">More details here: http://curl.haxx.se/docs/sslcerts.html</span></span><br><span class="line"><span class="comment">curl performs SSL certificate verification by default, using a &quot;bundle&quot;</span></span><br><span class="line"><span class="comment"> of Certificate Authority (CA) public keys (CA certs). If the default</span></span><br><span class="line"><span class="comment"> bundle file isn&#x27;t adequate, you can specify an alternate file</span></span><br><span class="line"><span class="comment"> using the –cacert option.</span></span><br><span class="line"><span class="comment">If this HTTPS server uses a certificate signed by a CA represented in</span></span><br><span class="line"><span class="comment"> the bundle, the certificate verification probably failed due to a</span></span><br><span class="line"><span class="comment"> problem with the certificate (it might be expired, or the name might</span></span><br><span class="line"><span class="comment"> not match the domain name in the URL).</span></span><br><span class="line"><span class="comment">If you&#x27;d like to turn off curl&#x27;s verification of the certificate, use</span></span><br><span class="line"><span class="comment"> the -k (or –insecure) option.</span></span><br></pre></td></tr></table></figure>
<h3 id="非对称加密和数字证书"><a href="#非对称加密和数字证书" class="headerlink" title="非对称加密和数字证书"></a>非对称加密和数字证书</h3><p>前面说过，HTTPS的数据传输是加密的。实际使用中，HTTPS利用的是对称与非对称加密算法结合的方式。  </p>
<p>对称加密，就是通信双方使用一个密钥，该密钥既用于数据加密（发送方），也用于数据解密（接收方）。</p>
<p>非对称加密，使用两个密钥。发送方使用公钥（公开密钥）对数据进行加密，数据接收方使用私钥对数据进行解密。  </p>
<p>实际操作中，单纯使用对称加密或单纯使用非对称加密都会存在一些问题，比如对称加密的密钥管理复杂；非对称加密的处理性能低、资源占用高等，因 此HTTPS结合了这两种方式。  </p>
<p>HTTPS服务端在连接建立过程（ssl shaking握手协议）中，会将自身的公钥发送给客户端。客户端拿到公钥后，与服务端协商数据传输通道的对称加密密钥-对话密钥，随后的这个协商过程则 是基于非对称加密的（因为这时客户端已经拿到了公钥，而服务端有私钥）。一旦双方协商出对话密钥，则后续的数据通讯就会一直使用基于该对话密 钥的对称加密算法了。  </p>
<p>上述过程有一个问题，那就是双方握手过程中，如何保障HTTPS服务端发送给客户端的公钥信息没有被篡改呢？实际应用中，HTTPS并非直接 传输公钥信息，而是使用携带公钥信息的数字证书来保证公钥的安全性和完整性。  </p>
<p>数字证书，又称互联网上的”身份证”，用于唯一标识一个组织或一个服务器的，这就好比我们日常生活中使用的”居民身份证”，用于唯一标识一个 人。服务端将数字证书传输给客户端，客户端如何校验这个证书的真伪呢？我们知道居民身份证是由国家统一制作和颁发的，个人向户 口所在地公安机关申请，国家颁发的身份证才具有法律 效力，任何地方这个身份证都是有效和可被接纳的。大悦城的会员卡也是一种身份标识，但你若用大悦城的会员卡去买机票，对不起， 不卖。航空公司可不认大悦城的会员卡，只认居民身份证。网站的证书也是同样的道理。一般来说数字证书从受信的权威证书授权机构 (Certification Authority，证书授权机构)买来的（免费的很少）。一般浏览器在出厂时就内置了诸多知名CA（如Verisign、GoDaddy、美国国防部、 CNNIC等）的数字证书校验方法，只要是这些CA机构颁发的证书，浏览器都能校验。对于CA未知的证书，浏览器则会报错（就像上面那个截图一 样）。主流浏览器都有证书管理功能，但鉴于这些功能比较高级，一般用户是不用去关心的。  </p>
<p>初步原理先讲到这，我们再回到上面的例子。  </p>
<h3 id="服务端私钥与证书"><a href="#服务端私钥与证书" class="headerlink" title="服务端私钥与证书"></a>服务端私钥与证书</h3><p>接上面的例子，我们来说说服务端私钥与证书的生成。  </p>
<p>go的http.ListenAndServeTLS需要两个特别参数，一个是服务端的私钥 文件路径，另外一个是服务端的数字证书文件路径。在测试环境，我们没有必要花钱去购买什么证书，利用openssl工具，我们可以自己生成相 关私钥和自签发的数字证书。  </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -<span class="keyword">out</span> <span class="keyword">server</span>.key <span class="number">2048</span></span><br></pre></td></tr></table></figure>
<p>用于生成服务端私钥文件server.key，后面的参数2048单位是bit，是私钥的长度。<br>openssl生成的私钥中包含了公钥的信息，我们可以根据私钥生成公钥：  </p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$openssl rsa -<span class="keyword">in</span> <span class="keyword">server</span>.key -out <span class="keyword">server</span>.key.<span class="keyword">public</span></span><br></pre></td></tr></table></figure>
<p>我们也可以根据私钥直接生成自签发的数字证书：  </p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$openssl req -<span class="keyword">new</span> -x509 -key <span class="keyword">server</span>.key -out <span class="keyword">server</span>.crt -days <span class="number">365</span></span><br></pre></td></tr></table></figure>
<p>server.key和server.crt将作为ListenAndServeTLS的两个输入参数。<br>我们编写一个Go程序来尝试与这个HTTPS server建立连接并通信。  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gohttps/4-https/client1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://localhost:8081&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个client，我们得到如下错误：  </p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$go run client1.go</span><br><span class="line"><span class="keyword">error: </span>Get https://localhost:8081: x509: certificate signed by unknown authority</span><br></pre></td></tr></table></figure>
<p>此时服务端也给出了错误日志提示：  </p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>/<span class="number">04</span>/<span class="number">30</span> <span class="number">16</span>:<span class="number">03</span>:<span class="number">31</span> http: TLS handshake <span class="keyword">error</span> from <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">62004</span>: <span class="comment">remote error: bad certificate</span></span><br></pre></td></tr></table></figure>
<p>显然从客户端日志来看，go实现的Client端默认也是要对服务端传过来的数字证书进行校验的，但客户端提示：这个证书是由不知名CA签发 的！<br>我们可以修改一下client1.go的代码，让client端略过对证书的校验：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gohttps/4-https/client2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr := &amp;http.Transport&#123;</span><br><span class="line">        TLSClientConfig:    &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">    resp, err := client.Get(<span class="string">&quot;https://localhost:8081&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过设置tls.Config的InsecureSkipVerify为true，client将不再对服务端的证书进行校验。执行后的结果 也证实了这一点：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in">go</span> run client2.<span class="built_in">go</span></span><br><span class="line">Hi, This <span class="built_in">is</span> an <span class="built_in">example</span> of http service <span class="keyword">in</span> golang!</span><br></pre></td></tr></table></figure>
<h3 id="对服务端的证书进行校验"><a href="#对服务端的证书进行校验" class="headerlink" title="对服务端的证书进行校验"></a>对服务端的证书进行校验</h3><p>多数时候，我们需要对服务端的证书进行校验，而不是像上面client2.go那样忽略这个校验。我大脑中的这个产品需要服务端和客户端双向 校验，我们先来看看如何能让client端实现对Server端证书的校验呢？ </p>
<p>client端校验证书的原理是什么呢？回想前面我们提到的浏览器内置了知名CA的相关信息，用来校验服务端发送过来的数字证书。那么浏览器 存储的到底是CA的什么信息呢？其实是CA自身的数字证书(包含CA自己的公钥)。而且为了保证CA证书的真实性，浏览器是在出厂时就内置了 这些CA证书的，而不是后期通过通信的方式获取的。CA证书就是用来校验由该CA颁发的数字证书的。  </p>
<p>那么如何使用CA证书校验Server证书的呢？这就涉及到数字证书到底是什么了！  </p>
<p>我们可以通过浏览器中的”https/ssl证书管理”来查看证书的内容，一般服务器证书都会包含诸如站点的名称和主机名、公钥、签发机构 (CA)名称和来自签发机构的签名等。我们重点关注这个来自签发机构的签名，因为对于证书的校验，就是使用客户端CA证书来验证服务端证书的签名是否这 个CA签的。  </p>
<p>通过签名验证我们可以来确认两件事：<br>1、服务端传来的数字证书是由某个特定CA签发的（如果是self-signed，也无妨），数字证书中的签名类似于日常生活中的签名，首先 验证这个签名签的是Tony Bai，而不是Tom Bai， Tony Blair等。<br>2、服务端传来的数字证书没有被中途篡改过。这类似于”Tony   Bai”有无数种写法，这里验证必须是我自己的那种写法，而不是张三、李四写的”Tony Bai”。  </p>
<p>一旦签名验证通过，我们因为信任这个CA，从而信任这个服务端证书。由此也可以看出，CA机构的最大资本就是其信用度。  </p>
<p>CA在为客户签发数字证书时是这样在证书上签名的：<br>数字证书由两部分组成：<br>1、C：证书相关信息（对象名称+过期时间+证书发布者+证书签名算法….）<br>2、S：证书的数字签名<br>其中的数字签名是通过公式S = F(Digest(C))得到的。  </p>
<p>Digest为摘要函数，也就是 md5、sha-1或sha256等单向散列算法，用于将无限输入值转换为一个有限长度的“浓缩”输出值。比如我们常用md5值来验证下载的大文件是否完 整。大文件的内容就是一个无限输入。大文件被放在网站上用于下载时，网站会对大文件做一次md5计算，得出一个128bit的值作为大文件的 摘要一同放在网站上。用户在下载文件后，对下载后的文件再进行一次本地的md5计算，用得出的值与网站上的md5值进行比较，如果一致，则大 文件下载完好，否则下载过程大文件内容有损坏或源文件被篡改。</p>
<p>F为签名函数。CA自己的私钥是唯一标识CA签名的，因此CA用于生成数字证书的签名函数一定要以自己的私钥作为一个输入参数。在RSA加密 系统中，发送端的解密函数就是一个以私钥作 为参数的函数，因此常常被用作签名函数使用。签名算法是与证书一并发送给接收 端的，比如apple的一个服务的证书中关于签名算法的描述是“带 RSA 加密的 SHA-256 ( 1.2.840.113549.1.1.11 )”。因此CA用私钥解密函数作为F，对C的摘要进行运算得到了客户数字证书的签名，好比大学毕业证上的校长签名，所有毕业证都是校长签发的。 </p>
<p>接收端接收服务端数字证书后，如何验证数字证书上携带的签名是这个CA的签名呢？接收端会运用下面算法对数字证书的签名进行校验：<br>F’(S) ?= Digest(C)<br>接收端进行两个计算，并将计算结果进行比对：<br>1、首先通过Digest(C)，接收端计算出证书内容（除签名之外）的摘要。<br>2、数字证书携带的签名是CA通过CA密钥加密摘要后的结果，因此接收端通过一个解密函数F’对S进行“解密”。RSA系统中，接收端使用 CA公钥对S进行“解密”，这恰是CA用私钥对S进行“加密”的逆过程。  </p>
<p>将上述两个运算的结果进行比较，如果一致，说明签名的确属于该CA，该证书有效，否则要么证书不是该CA的，要么就是中途被人篡改了。  </p>
<p>但对于self-signed(自签发)证书来说，接收端并没有你这个self-CA的数字证书，也就是没有CA公钥，也就没有办法对数字证 书的签名进行验证。因此如果要编写一个可以对self-signed证书进行校验的接收端程序的话，首先我们要做的就是建立一个属于自己的 CA，用该CA签发我们的server端证书，并将该CA自身的数字证书随客户端一并发布。</p>
<p>这让我想起了在《搭建自己的ngrok服务》一文中为ngrok服务端、客户端生成证书的那几个步骤，我们来重温并分析一下每一步都在做什么。<br>(1)openssl genrsa -out rootCA.key 2048<br>(2)openssl req -x509 -new -nodes -key rootCA.key -subj   “/CN=<em>.tunnel.tonybai.com” -days 5000 -out rootCA.pem<br>(3)openssl genrsa -out device.key 2048<br>(4)openssl req -new -key device.key -subj “/CN=</em>.tunnel.tonybai.com” -out device.csr<br>(5)openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000<br>(6)cp rootCA.pem assets/client/tls/ngrokroot.crt<br>(7)cp device.crt assets/server/tls/snakeoil.crt<br>(8)cp device.key assets/server/tls/snakeoil.key  </p>
<p>自己搭建ngrok服务，客户端要验证服务端证书，我们需要自己做CA，因此步骤(1)和步骤(2)就是生成CA自己的相关信息。<br>步骤(1) ，生成CA自己的私钥 rootCA.key<br>步骤(2)，根据CA自己的私钥生成自签发的数字证书，该证书里包含CA自己的公钥。<br>步骤(3)~(5)是用来生成ngrok服务端的私钥和数字证书（由自CA签发）。<br>步骤(3)，生成ngrok服务端私钥。<br>步骤(4)，生成Certificate Sign Request，CSR，证书签名请求。<br>步骤(5)，自CA用自己的CA私钥对服务端提交的csr进行签名处理，得到服务端的数字证书device.crt。<br>步骤(6)，将自CA的数字证书同客户端一并发布，用于客户端对服务端的数字证书进行校验。<br>步骤(7)和步骤(8)，将服务端的数字证书和私钥同服务端一并发布。<br>接下来我们来验证一下客户端对服务端数字证书进行验证（gohttps/5-verify-server-cert）！<br>首先我们来建立我们自己的CA，需要生成一个CA私钥和一个CA的数字证书: </p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$openssl genrsa -out ca.<span class="keyword">key</span> <span class="number">2048</span> </span><br><span class="line">Generating RSA <span class="keyword">private</span> <span class="keyword">key</span>, <span class="number">2048</span> bit <span class="type">long</span> modulus</span><br><span class="line">……….+++</span><br><span class="line">………………………….+++</span><br><span class="line">e <span class="built_in">is</span> <span class="number">65537</span> (<span class="number">0</span>×<span class="number">10001</span>)</span><br><span class="line">$openssl req -x509 -<span class="built_in">new</span> -nodes -<span class="keyword">key</span> ca.<span class="keyword">key</span> -subj <span class="string">&quot;/CN=tonybai.com&quot;</span> -days <span class="number">5000</span> -out ca.crt</span><br><span class="line">接下来，生成server端的私钥，生成数字证书请求，并用我们的ca私钥签发server的数字证书：</span><br><span class="line">openssl genrsa -out server.<span class="keyword">key</span> <span class="number">2048</span></span><br><span class="line">Generating RSA <span class="keyword">private</span> <span class="keyword">key</span>, <span class="number">2048</span> bit <span class="type">long</span> modulus</span><br><span class="line">….+++</span><br><span class="line">…………………….+++</span><br><span class="line">e <span class="built_in">is</span> <span class="number">65537</span> (<span class="number">0</span>×<span class="number">10001</span>)</span><br><span class="line">$openssl req -<span class="built_in">new</span> -<span class="keyword">key</span> server.<span class="keyword">key</span> -subj <span class="string">&quot;/CN=localhost&quot;</span> -out server.csr</span><br><span class="line">$openssl x509 -req -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.<span class="keyword">key</span> -CAcreateserial -out server.crt -days <span class="number">5000</span></span><br><span class="line">Signature ok</span><br><span class="line">subject=/CN=localhost</span><br><span class="line">Getting CA <span class="keyword">Private</span> <span class="keyword">Key</span></span><br></pre></td></tr></table></figure>
<p>现在我们的工作目录下有如下一些私钥和证书文件：<br>CA:<br>    私钥文件 ca.key<br>    数字证书 ca.crt<br>Server:<br>    私钥文件 server.key<br>    数字证书 server.crt<br>接下来，我们就来完成我们的程序。<br>Server端的程序几乎没有变化：  </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gohttps/5-verify-server-cert/server.go</span></span><br><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">main</span></span><br><span class="line"><span class="selector-tag">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">handler</span>(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="selector-tag">fmt</span><span class="selector-class">.Fprintf</span>(w,</span><br><span class="line">        <span class="string">&quot;Hi, This is an example of http service in golang!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">http</span><span class="selector-class">.HandleFunc</span>(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">    <span class="selector-tag">http</span><span class="selector-class">.ListenAndServeTLS</span>(<span class="string">&quot;:8081&quot;</span>,</span><br><span class="line">        <span class="string">&quot;server.crt&quot;</span>, <span class="string">&quot;server.key&quot;</span>, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client端程序变化较大，由于client端需要验证server端的数字证书，因此client端需要预先加载ca.crt，以用于服务端数字证书的校验：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gohttps/5-verify-server-cert/client.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := x509.NewCertPool()</span><br><span class="line">    caCertPath := <span class="string">&quot;ca.crt&quot;</span></span><br><span class="line">    caCrt, err := ioutil.ReadFile(caCertPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;ReadFile err:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pool.AppendCertsFromPEM(caCrt)</span><br><span class="line">    tr := &amp;http.Transport&#123;</span><br><span class="line">        TLSClientConfig: &amp;tls.Config&#123;RootCAs: pool&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">    resp, err := client.Get(<span class="string">&quot;https://localhost:8081&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Get error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行server和client:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in">go</span> run server.<span class="built_in">go</span></span><br><span class="line"><span class="built_in">go</span> run client.<span class="built_in">go</span></span><br><span class="line">Hi, This <span class="built_in">is</span> an <span class="built_in">example</span> of http service <span class="keyword">in</span> golang!</span><br></pre></td></tr></table></figure>
<h3 id="对客户端的证书进行校验-双向证书校验）"><a href="#对客户端的证书进行校验-双向证书校验）" class="headerlink" title="对客户端的证书进行校验(双向证书校验）"></a>对客户端的证书进行校验(双向证书校验）</h3><p>服务端可以要求对客户端的证书进行校验，以更严格识别客户端的身份，限制客户端的访问。<br>要对客户端数字证书进行校验，首先客户端需要先有自己的证书。我们以上面的例子为基础，生成客户端的私钥与证书。  </p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$openssl genrsa -out client.<span class="keyword">key</span> <span class="number">2048</span></span><br><span class="line">Generating RSA <span class="keyword">private</span> <span class="keyword">key</span>, <span class="number">2048</span> bit <span class="type">long</span> modulus</span><br><span class="line">………………..+++</span><br><span class="line">………………..+++</span><br><span class="line">e <span class="built_in">is</span> <span class="number">65537</span> (<span class="number">0</span>×<span class="number">10001</span>)</span><br><span class="line">$openssl req -<span class="built_in">new</span> -<span class="keyword">key</span> client.<span class="keyword">key</span> -subj <span class="string">&quot;/CN=tonybai_cn&quot;</span> -out client.csr</span><br><span class="line">$openssl x509 -req -<span class="keyword">in</span> client.csr -CA ca.crt -CAkey ca.<span class="keyword">key</span> -CAcreateserial -out client.crt -days <span class="number">5000</span></span><br><span class="line">Signature ok</span><br><span class="line">subject=/CN=tonybai_cn</span><br><span class="line">Getting CA <span class="keyword">Private</span> <span class="keyword">Key</span></span><br></pre></td></tr></table></figure>
<p>接下来我们来改造我们的程序，首先是server端。<br>首先server端需要要求校验client端的数字证书，并且加载用于校验数字证书的ca.crt，因此我们需要对server进行更加灵活的控制：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gohttps/6-dual-verify-certs/server.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> myhandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *myhandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter,</span></span></span><br><span class="line"><span class="params"><span class="function">                   r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w,</span><br><span class="line">        <span class="string">&quot;Hi, This is an example of http service in golang!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := x509.NewCertPool()</span><br><span class="line">    caCertPath := <span class="string">&quot;ca.crt&quot;</span></span><br><span class="line">    caCrt, err := ioutil.ReadFile(caCertPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;ReadFile err:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pool.AppendCertsFromPEM(caCrt)</span><br><span class="line">    s := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">&quot;:8081&quot;</span>,</span><br><span class="line">        Handler: &amp;myhandler&#123;&#125;,</span><br><span class="line">        TLSConfig: &amp;tls.Config&#123;</span><br><span class="line">            ClientCAs:  pool,</span><br><span class="line">            ClientAuth: tls.RequireAndVerifyClientCert,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    err = s.ListenAndServeTLS(<span class="string">&quot;server.crt&quot;</span>, <span class="string">&quot;server.key&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;ListenAndServeTLS err:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出代码通过将tls.Config.ClientAuth赋值为tls.RequireAndVerifyClientCert来实现Server强制校验client端证书。ClientCAs是用来校验客户端证书的ca certificate。<br>Client端变化也很大，需要加载client.key和client.crt用于server端连接时的证书校验：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gohttps/6-dual-verify-certs/client.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := x509.NewCertPool()</span><br><span class="line">    caCertPath := <span class="string">&quot;ca.crt&quot;</span></span><br><span class="line">    caCrt, err := ioutil.ReadFile(caCertPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;ReadFile err:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pool.AppendCertsFromPEM(caCrt)</span><br><span class="line">    cliCrt, err := tls.LoadX509KeyPair(<span class="string">&quot;client.crt&quot;</span>, <span class="string">&quot;client.key&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Loadx509keypair err:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    tr := &amp;http.Transport&#123;</span><br><span class="line">        TLSClientConfig: &amp;tls.Config&#123;</span><br><span class="line">            RootCAs:      pool,</span><br><span class="line">            Certificates: []tls.Certificate&#123;cliCrt&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">    resp, err := client.Get(<span class="string">&quot;https://localhost:8081&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Get error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，让我们来试着运行一下这两个程序，结果如下：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in">go</span> run server.<span class="built_in">go</span></span><br><span class="line"><span class="number">2015</span>/<span class="number">04</span>/<span class="number">30</span> <span class="number">22</span>:<span class="number">13</span>:<span class="number">33</span> http: TLS handshake <span class="built_in">error</span> from <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">53542</span>:</span><br><span class="line">tls: client&#x27;s certificate&#x27;s extended <span class="built_in">key</span> usage doesn&#x27;t permit it to be</span><br><span class="line">used <span class="keyword">for</span> client authentication</span><br><span class="line">$<span class="built_in">go</span> run client.<span class="built_in">go</span></span><br><span class="line">Get <span class="built_in">error</span>: Get https://localhost:<span class="number">8081</span>: remote <span class="built_in">error</span>: handshake failure</span><br></pre></td></tr></table></figure>
<p>失败了！从server端的错误日志来看，似乎是client端的client.crt文件不满足某些条件。<br>根据server端的错误日志，搜索了Golang的源码，发现错误出自crypto/tls/handshake_server.go。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, ku := <span class="keyword">range</span> certs[<span class="number">0</span>].ExtKeyUsage &#123;</span><br><span class="line">    <span class="keyword">if</span> ku == x509.ExtKeyUsageClientAuth &#123;</span><br><span class="line">        ok = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    c.sendAlert(alertHandshakeFailure)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;tls: client&#x27;s certificate&#x27;s extended key usage doesn&#x27;t permit it to be used for client authentication&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致判断是证书中的ExtKeyUsage信息应该包含clientAuth。翻看openssl的相关资料，了解到自CA签名的数字证书中包含的都是一些basic的信息，根本没有ExtKeyUsage的信息。我们可以用命令来查看一下当前client.crt的内容：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">openssl</span> <span class="string">x509</span> <span class="string">-text</span> <span class="string">-in</span> <span class="string">client.crt</span> <span class="string">-noout</span></span><br><span class="line"><span class="attr">Certificate:</span></span><br><span class="line">    <span class="attr">Data:</span></span><br><span class="line">        <span class="attr">Version:</span> <span class="number">1</span> <span class="string">(0×0)</span></span><br><span class="line">        <span class="attr">Serial Number:</span></span><br><span class="line">            <span class="string">d6:e3:f6:fa:ae:65:ed:df</span></span><br><span class="line">        <span class="attr">Signature Algorithm:</span> <span class="string">sha1WithRSAEncryption</span></span><br><span class="line">        <span class="attr">Issuer:</span> <span class="string">CN=tonybai.com</span></span><br><span class="line">        <span class="string">Validity</span></span><br><span class="line">            <span class="attr">Not Before:</span> <span class="string">Apr</span> <span class="number">30</span> <span class="number">14</span><span class="string">:11:34</span> <span class="number">2015 </span><span class="string">GMT</span></span><br><span class="line">            <span class="attr">Not After :</span> <span class="string">Jan</span>  <span class="number">6</span> <span class="number">14</span><span class="string">:11:34</span> <span class="number">2029 </span><span class="string">GMT</span></span><br><span class="line">        <span class="attr">Subject:</span> <span class="string">CN=tonybai_cn</span></span><br><span class="line">        <span class="attr">Subject Public Key Info:</span></span><br><span class="line">            <span class="attr">Public Key Algorithm:</span> <span class="string">rsaEncryption</span></span><br><span class="line">            <span class="attr">RSA Public Key:</span> <span class="string">(2048</span> <span class="string">bit)</span></span><br><span class="line">                <span class="string">Modulus</span> <span class="string">(2048</span> <span class="string">bit):</span></span><br><span class="line">                    <span class="attr">00:e4:12:22:50:75:ae:b2:8a:9e:56:d5:f3:7d:31:</span></span><br><span class="line">                    <span class="attr">7b:aa:75:5d:3f:90:05:4e:ff:ed:9a:0a:2a:75:15:</span></span><br><span class="line">                    <span class="string">…</span> <span class="string">…</span></span><br><span class="line">                <span class="attr">Exponent:</span> <span class="number">65537</span> <span class="string">(0×10001)</span></span><br><span class="line">    <span class="attr">Signature Algorithm:</span> <span class="string">sha1WithRSAEncryption</span></span><br><span class="line">        <span class="attr">76:3b:31:3e:9d:b0:66:ad:c0:03:d4:19:c6:f2:1a:52:91:d6:</span></span><br><span class="line">        <span class="attr">13:31:3a:c5:d5:58:ea:42:1d:b7:33:b8:43:a8:a8:28:91:ac:</span></span><br><span class="line">         <span class="string">…</span> <span class="string">…</span></span><br></pre></td></tr></table></figure>
<p>而偏偏golang的tls又要校验ExtKeyUsage，如此我们需要重新生成client.crt，并在生成时指定extKeyUsage。经过摸索，可以用如下方法重新生成client.crt：<br>1、创建文件client.ext<br>内容：<br>extendedKeyUsage=clientAuth<br>2、重建client.crt  </p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$openssl</span> x509 -req -<span class="keyword">in</span> client.csr -<span class="keyword">CA</span> <span class="keyword">ca</span>.crt -CAkey <span class="keyword">ca</span>.key -CAcreateserial -extfile client.ext -<span class="keyword">out</span> client.crt -days 5000</span><br><span class="line">Signature ok</span><br><span class="line">subject=/CN=tonybai_cn</span><br><span class="line">Getting <span class="keyword">CA</span> Private Key</span><br></pre></td></tr></table></figure>
<p>再通过命令查看一下新client.crt：<br>看到输出的文本中多了这么几行：<br>        X509v3 extensions:<br>            X509v3 Extended Key Usage:<br>                TLS Web Client Authentication<br>这说明client.crt的extended key usage已经添加成功了。我们再来执行一下server和client：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">go</span> run client.<span class="built_in">go</span></span><br><span class="line">Hi, This <span class="built_in">is</span> an <span class="built_in">example</span> of http service <span class="keyword">in</span> golang!</span><br></pre></td></tr></table></figure>
<p>client端证书验证成功，也就是说双向证书验证均ok了。  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过上面的例子可以看出，使用golang开发https相关程序十分便利，Golang标准库已经实现了TLS 1.2版本协议。上述所有example代码均放在我的github上的experiments/gohttps中。</p>
<blockquote>
<p>作者: Tonybai 出处: <a target="_blank" rel="noopener" href="http://tonybai.com/2015/04/30/go-and-https/">http://tonybai.com/2015/04/30/go-and-https/</a> </p>
</blockquote>
</div><div class="tags"><a href="/tags/golang/"><i class="fa fa-tag"></i>golang</a><a href="/tags/https/"><i class="fa fa-tag"></i>https</a></div><div class="post-nav"><a class="pre" href="/2017/07/14/hexo-github-pages/">利用用 hexo和 github pages 搭建个人博客</a><a class="next" href="/2016/11/15/drone-gogs/">利用 Drone 和 Gogs 搭建部署平台</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/drone/" style="font-size: 15px;">drone</a> <a href="/tags/CI-CD/" style="font-size: 15px;">CI,CD</a> <a href="/tags/gogs/" style="font-size: 15px;">gogs</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/https/" style="font-size: 15px;">https</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/grpc/" style="font-size: 15px;">grpc</a> <a href="/tags/kratos/" style="font-size: 15px;">kratos</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" style="font-size: 15px;">服务发现</a> <a href="/tags/etcd/" style="font-size: 15px;">etcd</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/06/08/grpc-blancer-session-keep/">gRPC服务负载均衡中的会话保存</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/grpc-server-discover-etcd/">gRPC的服务发现和负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/14/use-go-module/">Go Module 迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/hexo-github-pages/">利用用 hexo和 github pages 搭建个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/https-and-golang/">HTTPs and Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/drone-gogs/">利用 Drone 和 Gogs 搭建部署平台</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="https://program-think.blogspot.com/" title="编程随想" target="_blank">编程随想</a><ul></ul><a href="http://tonybai.com/" title="tonybai" target="_blank">tonybai</a><ul></ul><a href="http://colobu.com/" title="鸟窝" target="_blank">鸟窝</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">记忆源泉.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>